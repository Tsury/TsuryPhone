#!/usr/bin/env python3
import os
import sys
import argparse

def convert_file_to_c_array(filepath, array_name):
    """Reads a binary file and returns a C array string of its bytes for definitions."""
    with open(filepath, "rb") as f:
        data = f.read()
    # Convert each byte to a hexadecimal representation.
    hex_bytes = [f"0x{byte:02x}" for byte in data]
    bytes_per_line = 12  # adjust for formatting as needed
    lines = []
    for i in range(0, len(hex_bytes), bytes_per_line):
        line = ", ".join(hex_bytes[i:i+bytes_per_line])
        if i + bytes_per_line < len(hex_bytes):
            line += ","
        lines.append("  " + line)
    array_def = f"const unsigned char {array_name}[] = {{\n" + "\n".join(lines) + "\n};\n"
    array_def += f"unsigned int {array_name}_len = {len(data)};\n"
    return array_def

def main():
    parser = argparse.ArgumentParser(
        description="Convert all MP3 files in a folder into a C header and source file."
    )
    parser.add_argument(
        "folder",
        help="Folder containing MP3 files"
    )
    parser.add_argument(
        "-o", "--output",
        default="music.h",
        help="Output header file name (default: music.h). The corresponding .cpp file will be generated automatically."
    )
    args = parser.parse_args()

    folder = args.folder
    header_file = args.output

    if not os.path.isdir(folder):
        print(f"Error: '{folder}' is not a valid directory.")
        sys.exit(1)

    # Determine source file name by replacing .h extension with .cpp
    if header_file.lower().endswith(".h"):
        source_file = header_file[:-2] + ".cpp"
    else:
        source_file = header_file + ".cpp"

    # Look for a numbers.txt file in the same folder.
    numbers_filename = os.path.join(folder, "numbers.txt")
    caller_dict = {}  # mapping: caller number (string) -> base name of MP3 file
    if os.path.isfile(numbers_filename):
        with open(numbers_filename, "r") as nf:
            for line in nf:
                line = line.strip()
                if not line:
                    continue
                # Expected format: number,mp3BaseName
                parts = line.split(",")
                if len(parts) >= 2:
                    number = parts[0].strip()
                    base = parts[1].strip()
                    caller_dict[number] = base
    else:
        caller_dict = None

    # Find all files ending with .mp3 (case-insensitive)
    mp3_files = [f for f in os.listdir(folder) if f.lower().endswith(".mp3")]
    if not mp3_files:
        print("No MP3 files found in the specified folder.")
        sys.exit(1)

    mp3_files.sort()  # sort alphabetically for consistency

    # Collect base names for later use, and build array definitions.
    base_names = []
    arrays_definitions = {}  # dictionary: base_name -> array definition string
    for filename in mp3_files:
        base_name = os.path.splitext(filename)[0]
        base_names.append(base_name)
        array_name = base_name + "_mp3"
        filepath = os.path.join(folder, filename)
        arrays_definitions[base_name] = convert_file_to_c_array(filepath, array_name)

    # --- Generate the header file (declarations) ---
    try:
        with open(header_file, "w") as out:
            out.write("#pragma once\n\n")
            # Always include these at the top.
            out.write("#include <Arduino.h>\n")
            out.write("#include <unordered_map>\n")
            out.write("#include <string>\n\n")
            out.write("// Generated header file containing MP3 file arrays\n")
            out.write("// Generated by mp3_to_header.py\n\n")
            
            # Forward declarations for each MP3 array and length.
            for base_name in base_names:
                array_name = base_name + "_mp3"
                out.write(f"extern const unsigned char {array_name}[];\n")
                out.write(f"extern unsigned int {array_name}_len;\n")
            out.write("\n")
            
            # Structure declaration for MP3File.
            out.write("// Structure to hold MP3 file information\n")
            out.write("typedef struct {\n")
            out.write("    const char* fileName;         // File name (or path if needed)\n")
            out.write("    const unsigned char* data;    // Pointer to MP3 data\n")
            out.write("    unsigned int length;          // Length of the MP3 data\n")
            out.write("} MP3File;\n\n")
            
            # Declarations for each strongly typed MP3File instance.
            for base_name in base_names:
                out.write(f"extern const MP3File {base_name};\n")
            out.write("\n")
            
            # Declaration for the master array and count.
            out.write("extern MP3File mp3Files[];\n")
            out.write("extern unsigned int mp3FilesCount;\n");
            
            # Always declare the dialedDigitsToMp3s dictionary.
            out.write("extern std::unordered_map<std::string, MP3File> dialedDigitsToMp3s;\n");
            
            # If numbers.txt exists, declare the callerNumbers dictionary and helper functions.
            if caller_dict is not None:
                out.write("extern std::unordered_map<std::string, MP3File> callerNumbersToMp3s;\n");
                out.write("\n");
                out.write("const bool hasMp3ForCaller(const String &callerNumber);\n");
                out.write("const MP3File getMp3ForCaller(const String &callerNumber);\n");
        print(f"Header file generated: {header_file}")
    except Exception as e:
        print(f"Error writing header file: {e}")
        sys.exit(1)
    
    # --- Generate the source file (definitions) ---
    try:
        with open(source_file, "w") as out:
            out.write("// Generated source file containing MP3 file definitions\n")
            out.write("// Generated by mp3_to_header.py\n\n")
            out.write(f'#include "{os.path.basename(header_file)}"\n\n')
            
            # Write the definitions for each MP3 array.
            for base_name in base_names:
                out.write(f"// {base_name}.mp3\n")
                out.write(arrays_definitions[base_name])
                out.write("\n")
            
            # Define the MP3File instances using the arrays defined above.
            for filename, base_name in zip(mp3_files, base_names):
                array_name = base_name + "_mp3"
                out.write(f"const MP3File {base_name} = {{ \"{filename}\", {array_name}, {array_name}_len }};\n")
            out.write("\n")
            
            # Define the master array and the count.
            out.write("MP3File mp3Files[] = {\n")
            for base_name in base_names:
                out.write(f"    {base_name},\n")
            out.write("};\n\n")
            out.write("unsigned int mp3FilesCount = sizeof(mp3Files) / sizeof(mp3Files[0]);\n")
            
            # If callerNumbers mapping exists, output the dictionary definition and functions.
            if caller_dict is not None:
                out.write("\nstd::unordered_map<std::string, MP3File> callerNumbersToMp3s = {\n")
                for number, base in caller_dict.items():
                    if base in base_names:
                        out.write(f'    {{"{number}", {base}}},\n')
                out.write("};\n")
                
                out.write("\nconst bool hasMp3ForCaller(const String &callerNumber) {\n")
                out.write("    return callerNumbersToMp3s.find(std::string(callerNumber.c_str())) != callerNumbersToMp3s.end();\n")
                out.write("}\n\n")
                out.write("const MP3File getMp3ForCaller(const String &callerNumber) {\n")
                out.write("    return callerNumbersToMp3s[std::string(callerNumber.c_str())];\n")
                out.write("}\n")
            
            # Always output the dictionary for dialed digits.
            out.write("\nstd::unordered_map<std::string, MP3File> dialedDigitsToMp3s = {\n")
            out.write('    {"0", dial_0},\n')
            out.write('    {"1", dial_1},\n')
            out.write('    {"2", dial_2},\n')
            out.write('    {"3", dial_3},\n')
            out.write('    {"4", dial_4},\n')
            out.write('    {"5", dial_5},\n')
            out.write('    {"6", dial_6},\n')
            out.write('    {"7", dial_7},\n')
            out.write('    {"8", dial_8},\n')
            out.write('    {"9", dial_9},\n')
            out.write("};\n")
        print(f"Source file generated: {source_file}")
    except Exception as e:
        print(f"Error writing source file: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
